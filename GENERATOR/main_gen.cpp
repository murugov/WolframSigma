#include "WolfGen.hpp"

hash_t bad_hash[] = {  
                        HashStr("("), HashStr(")"),
                        HashStr("["), HashStr("]"),
                        HashStr("{"), HashStr("}"),
                        HashStr(","), HashStr(";"),
                        HashStr("="), HashStr("def"),
                        HashStr("D"), HashStr("plot")
                    };
static const size_t NUM_BAD_SYMS = sizeof(bad_hash) / sizeof(bad_hash[0]);


int main()
{
    FILE *SourceFuncFile = fopen(PATH_TO_SRC_FUNC_FILE, "r");
    if (IS_BAD_PTR(SourceFuncFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_FUNC_FILE); return EXIT_FAILURE; }
    
    FILE *WolfOpFile     = fopen(PATH_TO_WOLF_OP_H, "w");
    if (IS_BAD_PTR(WolfOpFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!" ANSI_COLOR_RESET, PATH_TO_WOLF_OP_H); return EXIT_FAILURE; }
    
    FILE *OpInstrSetFile = fopen(PATH_TO_OP_INSTR_SET, "w");
    if (IS_BAD_PTR(OpInstrSetFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!" ANSI_COLOR_RESET, PATH_TO_OP_INSTR_SET); return EXIT_FAILURE; }


    char* buffer = NULL;
    size_t len_buffer = 0;
    int count_line = 0;
    char **arr_ptr = TXTreader(SourceFuncFile, buffer, &len_buffer, &count_line, NULL);
    if (IS_BAD_PTR(arr_ptr)) printf(ANSI_COLOR_RED "Error reading %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_FUNC_FILE);

    RemoveComments(arr_ptr, &count_line);

    if (GenWolfOp(WolfOpFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!" ANSI_COLOR_RESET, PATH_TO_WOLF_OP_H);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    if (GenOpInstrSet(OpInstrSetFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!" ANSI_COLOR_RESET, PATH_TO_OP_INSTR_SET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    free(arr_ptr);


    FILE *SourceKeyFile  = fopen(PATH_TO_SRC_KEY_FILE, "r");
    if (IS_BAD_PTR(SourceKeyFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_KEY_FILE); return EXIT_FAILURE; }

    FILE *KeywordSetFile = fopen(PATH_TO_KEYWORD_SET, "w");
    if (IS_BAD_PTR(KeywordSetFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!" ANSI_COLOR_RESET, PATH_TO_KEYWORD_SET); return EXIT_FAILURE; }


    buffer = NULL;
    len_buffer = 0;
    count_line = 0;
    arr_ptr = TXTreader(SourceKeyFile, buffer, &len_buffer, &count_line, NULL);
    if (IS_BAD_PTR(arr_ptr)) printf(ANSI_COLOR_RED "Error reading %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_KEY_FILE);

    RemoveComments(arr_ptr, &count_line);

    if (GenKeywordSet(KeywordSetFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!" ANSI_COLOR_RESET, PATH_TO_KEYWORD_SET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);


    free(arr_ptr);
    fclose(SourceFuncFile);
    fclose(SourceKeyFile);
    fclose(WolfOpFile);
    fclose(OpInstrSetFile);
    fclose(KeywordSetFile);

    return 0;
}


GenErr_t GenWolfOp(FILE *WolfOpFile, char **arr_ptr, int count_line)
{
    if (IS_BAD_PTR(WolfOpFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) return GEN_ERROR;
        
    fprintf(WolfOpFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    funcInfo *func_infos = (funcInfo*)calloc((size_t)count_line, sizeof(funcInfo));
    if (IS_BAD_PTR(func_infos)) return GEN_ERROR;

    int actual_count = 0;
    int max_name_len = 0;

    for (int line = 0; line < count_line; ++line)
    {
        if (*arr_ptr[line] == '\0') continue;
        
        int name_len = 0;
        if (sscanf(arr_ptr[line], "%15[^:]%n: \"%15[^\"]\";", func_infos[actual_count].name, &name_len, func_infos[actual_count].op) == 2)
        {
            if (name_len > max_name_len)
                max_name_len = name_len;
            actual_count++;
        }
        else
        {
            printf(ANSI_COLOR_RED "Error parsing line %d: '%s'\n" ANSI_COLOR_RESET, line, arr_ptr[line]);
            free(func_infos);
            return GEN_ERROR;
        }
    }

    fprintf(WolfOpFile, "#ifndef WOLF_OP_HPP\n"
                        "#define WOLF_OP_HPP\n\n\n");

    fprintf(WolfOpFile, "enum HashOp\n");
    fprintf(WolfOpFile, "{\n");

    for (int i = 0; i < actual_count - 1; ++i)
        fprintf(WolfOpFile, "\tHASH_%-*s = 0x%lX,\n", max_name_len, func_infos[i].name, HashStr(func_infos[i].op));
    
    if (actual_count > 0)
        fprintf(WolfOpFile, "\tHASH_%-*s = 0x%lX\n", max_name_len, func_infos[actual_count - 1].name, HashStr(func_infos[actual_count - 1].op));
    

    fprintf(WolfOpFile, "};\n\n");

    fprintf(WolfOpFile, "struct calc_context\n");
    fprintf(WolfOpFile, "{\n");
    fprintf(WolfOpFile, "    double left_val;\n");
    fprintf(WolfOpFile, "    double right_val;\n");
    fprintf(WolfOpFile, "};\n\n");
    
    fprintf(WolfOpFile, "struct diff_context\n");
    fprintf(WolfOpFile, "{\n");
    fprintf(WolfOpFile, "    node_t *node_left;\n");
    fprintf(WolfOpFile, "    node_t *node_right;\n");
    fprintf(WolfOpFile, "    hash_t hash_indep_var;\n");
    fprintf(WolfOpFile, "};\n\n\n");
    
    for (int i = 0; i < actual_count; ++i)
    {
        hash_t target_hash = HashStr(func_infos[i].op);
        if (!bsearch(&target_hash, bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash))
        {
            fprintf(WolfOpFile, "double calc%s(calc_context *calc_params);\n", 
                    func_infos[i].name);
            fprintf(WolfOpFile, "node_t *diff%s(diff_context *diff_params);\n\n", 
                    func_infos[i].name);
        }
    }

    fprintf(WolfOpFile, "typedef double (*calc_t)(calc_context *calc_params);\n");
    fprintf(WolfOpFile, "typedef node_t *(*diff_t)(diff_context *diff_params);\n\n\n");
    
    fprintf(WolfOpFile, "#endif\n");

    free(func_infos);
    return GEN_SUCCESS;
}


GenErr_t GenOpInstrSet(FILE *OpInstrSetFile, char **arr_ptr, int count_line)
{
    if (IS_BAD_PTR(OpInstrSetFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) return GEN_ERROR;
        
    fprintf(OpInstrSetFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    fprintf(OpInstrSetFile, "const op_t op_instr_set[] =\n");
    fprintf(OpInstrSetFile, "{\n");

    static const hash_t HASH_LOG  = HashStr("LOG");
    static const hash_t HASH_PLUS = HashStr("+");
    static const hash_t HASH_MINUS = HashStr("-");
    static const hash_t HASH_MUL   = HashStr("*");
    static const hash_t HASH_DIV   = HashStr("/");
    static const hash_t HASH_POW   = HashStr("^");
    
    op_instr_t *func_infos = (op_instr_t*)calloc((size_t)count_line, sizeof(op_instr_t));
    if (IS_BAD_PTR(func_infos)) return GEN_ERROR;

    int actual_count = 0;
    size_t max_name_len = 0;
    size_t max_op_len = 0;
    int max_num_width = 0;

    for (int line = 0; line < count_line; ++line)
    {
        if (*arr_ptr[line] == '\0') 
            continue;
        
        if (sscanf(arr_ptr[line], "%15[^:]: \"%15[^\"]\";", 
                   func_infos[actual_count].name, 
                   func_infos[actual_count].op) == 2)
        {
            hash_t target_hash = HashStr(func_infos[actual_count].op);
            if (bsearch(&target_hash, bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash)) continue;
            
            size_t name_len = strlen(func_infos[actual_count].name);
            size_t op_len   = strlen(func_infos[actual_count].op);
            
            if (name_len > max_name_len) max_name_len = name_len;
            if (op_len > max_op_len) max_op_len = op_len;
            
            func_infos[actual_count].hash = target_hash;
            
            hash_t op_hash = func_infos[actual_count].hash;
            hash_t name_hash = HashStr(func_infos[actual_count].name);
            
            if (name_hash == HASH_LOG || op_hash == HASH_PLUS || 
                op_hash == HASH_MINUS || op_hash == HASH_MUL || 
                op_hash == HASH_DIV || op_hash == HASH_POW)
            {
                func_infos[actual_count].num_args = 2;
            }
            else
            {
                func_infos[actual_count].num_args = 1;
            }
            
            if (func_infos[actual_count].num_args > max_num_width)
                max_num_width = func_infos[actual_count].num_args;
            
            actual_count++;
        }
    }
    
    qsort(func_infos, (size_t)actual_count, sizeof(op_instr_t), CmpOpInstrSetByHash);

    for (int i = 0; i < actual_count - 1; ++i)
    {
        fprintf(OpInstrSetFile, 
                "\t{HASH_%-*s, \"%s\",%*d, calc%s, diff%s},\n",
                (int)max_name_len, func_infos[i].name, 
                func_infos[i].op,
                max_num_width + 1, 
                func_infos[i].num_args,
                func_infos[i].name, 
                func_infos[i].name);
    }
    
    if (actual_count > 0)
    {
        fprintf(OpInstrSetFile,
                "\t{HASH_%-*s, \"%s\",%*d, calc%s, diff%s}\n",
                (int)max_name_len, func_infos[actual_count - 1].name,
                func_infos[actual_count - 1].op,
                max_num_width + 1,
                func_infos[actual_count - 1].num_args,
                func_infos[actual_count - 1].name,
                func_infos[actual_count - 1].name);
    }

    fprintf(OpInstrSetFile, "};\n\n");
    
    fprintf(OpInstrSetFile, "#define LEN_INSTR_SET sizeof(op_instr_set) / sizeof(*op_instr_set)\n");

    free(func_infos);
    return GEN_SUCCESS;
}


GenErr_t GenKeywordSet(FILE *KeywordSetFile, char **arr_ptr, int count_line)
{
    if (IS_BAD_PTR(KeywordSetFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) return GEN_ERROR;
        
    fprintf(KeywordSetFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    fprintf(KeywordSetFile, "const keyword_t keyword_set[] =\n");
    fprintf(KeywordSetFile, "{\n");
    
    keyword_set_t *func_infos = (keyword_set_t*)calloc((size_t)count_line, sizeof(keyword_set_t));
    if (IS_BAD_PTR(func_infos)) return GEN_ERROR;

    int actual_count    = 0;
    size_t max_name_len = 0;
    size_t max_key_len  = 0;

    for (int line = 0; line < count_line; ++line)
    {
        if (*arr_ptr[line] == '\0') 
            continue;
        
        if (sscanf(arr_ptr[line], "%15[^:]: \"%15[^\"]\";", 
                   func_infos[actual_count].name, 
                   func_infos[actual_count].key) == 2)
        {
            size_t name_len = strlen(func_infos[actual_count].name);
            size_t key_len  = strlen(func_infos[actual_count].key);
            
            if (name_len > max_name_len) max_name_len = name_len;
            if (key_len > max_key_len) max_key_len = key_len;
            
            if (key_len == 1)
                func_infos[actual_count].hash = (hash_t)(*func_infos[actual_count].key);
            else
                func_infos[actual_count].hash = HashStr(func_infos[actual_count].key);

            actual_count++;
        }
    }
    
    qsort(func_infos, (size_t)actual_count, sizeof(keyword_set_t), CmpKeywordSetByHash);

    for (int i = 0; i < actual_count - 1; ++i)
    {
        fprintf(KeywordSetFile, 
                "\t{TOKEN_%-*s, \"%s\",\t%zu ,\t0x%zX},\n",
                (int)max_name_len, func_infos[i].name, 
                func_infos[i].key,
                strlen(func_infos[i].key),
                func_infos[i].hash);
    }
    
    if (actual_count > 0)
    {
        fprintf(KeywordSetFile, 
                "\t{TOKEN_%-*s, \"%s\",\t%zu ,\t0x%zX}\n",
                (int)max_name_len, func_infos[actual_count - 1].name, 
                func_infos[actual_count - 1].key,
                strlen(func_infos[actual_count - 1].key),
                func_infos[actual_count - 1].hash);
    }

    fprintf(KeywordSetFile, "};\n\n");
    
    fprintf(KeywordSetFile, "#define LEN_KEYWORD_SET sizeof(keyword_set) / sizeof(*keyword_set)\n");

    free(func_infos);
    return GEN_SUCCESS;
}


int CmpOpInstrSetByHash(const void *a, const void *b)
{
    const op_instr_t *op_instr_a = (const op_instr_t*)a;
    const op_instr_t *op_instr_b = (const op_instr_t*)b;

    if (op_instr_a->hash > op_instr_b->hash)
        return 1;
    if (op_instr_a->hash == op_instr_b->hash)
        return 0;
    return -1;
}


int CmpKeywordSetByHash(const void *a, const void *b)
{
    const keyword_set_t *keyword_a = (const keyword_set_t*)a;
    const keyword_set_t *keyword_b = (const keyword_set_t*)b;

    if (keyword_a->hash > keyword_b->hash)
        return 1;
    if (keyword_a->hash == keyword_b->hash)
        return 0;
    return -1;
}


int CmpByHash(const void *a, const void *b)
{
    const hash_t *hash_a = (const hash_t*)a;
    const hash_t *hash_b = (const hash_t*)b;

    if (*hash_a > *hash_b)
        return 1;
    if (*hash_a == *hash_b)
        return 0;
    return -1;
}


void RemoveComments(char** arr_ptr, int *count_line)
{
    for (int i = 0; i < *count_line; ++i)
    {
        char* colon = strchr(arr_ptr[i], '#');

        if (colon != NULL)
            *colon = '\0';
    }
}