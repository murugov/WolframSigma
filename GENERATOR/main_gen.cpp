#include "WolfGen.h"

hash_t bad_hash[] = {  
                        HashStr("("), HashStr(")"),
                        HashStr("["), HashStr("]"),
                        HashStr("{"), HashStr("}"),
                        HashStr(","), HashStr(";"),
                        HashStr("="),
                        HashStr("D"), HashStr("plot")
                    };
static const size_t NUM_BAD_SYMS = sizeof(bad_hash) / sizeof(bad_hash[0]);


int main()
{
    FILE *SourceFile     = fopen(PATH_TO_SRC_FILE, "r");
    if (IS_BAD_PTR(SourceFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_FILE); return EXIT_FAILURE; }
    
    FILE *WolfOpFile     = fopen(PATH_TO_WOLF_OP_H, "w");
    if (IS_BAD_PTR(WolfOpFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!" ANSI_COLOR_RESET, PATH_TO_WOLF_OP_H); return EXIT_FAILURE; }
    
    FILE *OpInstrSetFile = fopen(PATH_TO_OP_INSTR_SET, "w");
    if (IS_BAD_PTR(OpInstrSetFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!" ANSI_COLOR_RESET, PATH_TO_OP_INSTR_SET); return EXIT_FAILURE; }


    char* buffer = NULL;
    size_t len_buffer = 0;
    size_t count_line = 0;
    char **arr_ptr = TXTreader(SourceFile, buffer, &len_buffer, &count_line);
    if (IS_BAD_PTR(arr_ptr)) printf(ANSI_COLOR_RED "Error reading %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_FILE);

    RemoveComments(arr_ptr, &count_line);

    if (GenWolfOp(WolfOpFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!" ANSI_COLOR_RESET, PATH_TO_WOLF_OP_H);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    if (GenOpInstrSet(OpInstrSetFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!" ANSI_COLOR_RESET, PATH_TO_OP_INSTR_SET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    free(arr_ptr);
    fclose(SourceFile);
    fclose(WolfOpFile);
    fclose(OpInstrSetFile);
    
    return 0;
}


GenErr_t GenWolfOp(FILE *WolfOpFile, char **arr_ptr, size_t count_line)
{
    if (IS_BAD_PTR(WolfOpFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) return GEN_ERROR;
        
    fprintf(WolfOpFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    funcInfo *func_infos = (funcInfo*)calloc(count_line, sizeof(funcInfo));
    if (IS_BAD_PTR(func_infos)) return GEN_ERROR;

    size_t actual_count = 0;
    int max_name_len = 0;

    for (size_t line = 0; line < count_line; ++line)
    {
        if (*arr_ptr[line] == '\0') continue;
        
        int name_len = 0;
        if (sscanf(arr_ptr[line], "%15[^:]%n: \"%15[^\"]\";", func_infos[actual_count].name, &name_len, func_infos[actual_count].op) == 2)
        {
            if (name_len > max_name_len)
                max_name_len = name_len;
            actual_count++;
        }
        else
        {
            printf(ANSI_COLOR_RED "Error parsing line %zu: '%s'\n" ANSI_COLOR_RESET, line, arr_ptr[line]);
            free(func_infos);
            return GEN_ERROR;
        }
    }

    fprintf(WolfOpFile, "#ifndef WOLF_OP_H\n"
                        "#define WOLF_OP_H\n\n\n");

    fprintf(WolfOpFile, "enum HashOp\n");
    fprintf(WolfOpFile, "{\n");

    for (size_t i = 0; i < actual_count - 1; ++i)
        fprintf(WolfOpFile, "\tHASH_%-*s = 0x%lX,\n", max_name_len, func_infos[i].name, HashStr(func_infos[i].op));
    
    if (actual_count > 0)
        fprintf(WolfOpFile, "\tHASH_%-*s = 0x%lX\n", max_name_len, func_infos[actual_count - 1].name, HashStr(func_infos[actual_count - 1].op));
    

    fprintf(WolfOpFile, "};\n\n");

    fprintf(WolfOpFile, "struct calc_context\n");
    fprintf(WolfOpFile, "{\n");
    fprintf(WolfOpFile, "    double left_val;\n");
    fprintf(WolfOpFile, "    double right_val;\n");
    fprintf(WolfOpFile, "};\n\n");
    
    fprintf(WolfOpFile, "struct diff_context\n");
    fprintf(WolfOpFile, "{\n");
    fprintf(WolfOpFile, "    node_t *node_left;\n");
    fprintf(WolfOpFile, "    node_t *node_right;\n");
    fprintf(WolfOpFile, "    hash_t hash_indep_var;\n");
    fprintf(WolfOpFile, "};\n\n\n");
    
    for (size_t i = 0; i < actual_count; ++i)
    {
        hash_t target_hash = HashStr(func_infos[i].op);
        if (!bsearch(&target_hash, bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash))
        {
            fprintf(WolfOpFile, "double calc%s(calc_context *calc_params);\n", 
                    func_infos[i].name);
            fprintf(WolfOpFile, "node_t *diff%s(diff_context *diff_params);\n\n", 
                    func_infos[i].name);
        }
    }

    fprintf(WolfOpFile, "typedef double (*calc_t)(calc_context *calc_params);\n");
    fprintf(WolfOpFile, "typedef node_t *(*diff_t)(diff_context *diff_params);\n\n\n");
    
    fprintf(WolfOpFile, "#endif\n");

    free(func_infos);
    return GEN_SUCCESS;
}


GenErr_t GenOpInstrSet(FILE *OpInstrSetFile, char **arr_ptr, size_t count_line)
{
    if (IS_BAD_PTR(OpInstrSetFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) 
        return GEN_ERROR;
        
    fprintf(OpInstrSetFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    fprintf(OpInstrSetFile, "const op_t op_instr_set[] =\n");
    fprintf(OpInstrSetFile, "{\n");

    static const hash_t HASH_LOG  = HashStr("LOG");
    static const hash_t HASH_PLUS = HashStr("+");
    static const hash_t HASH_MINUS = HashStr("-");
    static const hash_t HASH_MUL   = HashStr("*");
    static const hash_t HASH_DIV   = HashStr("/");
    static const hash_t HASH_POW   = HashStr("^");
    
    op_instr_t *func_infos = (op_instr_t*)calloc(count_line, sizeof(op_instr_t));
    if (IS_BAD_PTR(func_infos)) 
        return GEN_ERROR;

    size_t actual_count = 0;
    size_t max_name_len = 0;
    size_t max_op_len = 0;
    int max_num_width = 0;

    for (size_t line = 0; line < count_line; ++line)
    {
        if (*arr_ptr[line] == '\0') 
            continue;
        
        if (sscanf(arr_ptr[line], "%15[^:]: \"%15[^\"]\";", 
                   func_infos[actual_count].name, 
                   func_infos[actual_count].op) == 2)
        {
            // Проверяем, не является ли операция "плохой" (как в GenWolfOp)
            hash_t target_hash = HashStr(func_infos[actual_count].op);
            if (bsearch(&target_hash, bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash))
            {
                // Пропускаем "плохие" операции
                continue;
            }
            
            size_t name_len = strlen(func_infos[actual_count].name);
            size_t op_len = strlen(func_infos[actual_count].op);
            
            if (name_len > max_name_len) max_name_len = name_len;
            if (op_len > max_op_len) max_op_len = op_len;
            
            func_infos[actual_count].hash = target_hash;
            
            hash_t op_hash = func_infos[actual_count].hash;
            hash_t name_hash = HashStr(func_infos[actual_count].name);
            
            if (name_hash == HASH_LOG || op_hash == HASH_PLUS || 
                op_hash == HASH_MINUS || op_hash == HASH_MUL || 
                op_hash == HASH_DIV || op_hash == HASH_POW)
            {
                func_infos[actual_count].num_args = 2;
            }
            else
            {
                func_infos[actual_count].num_args = 1;
            }
            
            if (func_infos[actual_count].num_args > max_num_width)
                max_num_width = func_infos[actual_count].num_args;
            
            actual_count++;
        }
    }
    
    qsort(func_infos, actual_count, sizeof(op_instr_t), CmpOpInstrSetByHash);

    for (size_t i = 0; i < actual_count - 1; ++i)
    {
        fprintf(OpInstrSetFile, 
                "\t{HASH_%-*s, \"%s\",%*d, calc%s, diff%s},\n",
                (int)max_name_len, func_infos[i].name, 
                func_infos[i].op,
                max_num_width + 1, 
                func_infos[i].num_args,
                func_infos[i].name, 
                func_infos[i].name);
    }
    
    if (actual_count > 0)
    {
        fprintf(OpInstrSetFile,
                "\t{HASH_%-*s, \"%s\",%*d, calc%s, diff%s}\n",
                (int)max_name_len, func_infos[actual_count - 1].name,
                func_infos[actual_count - 1].op,
                max_num_width + 1,
                func_infos[actual_count - 1].num_args,
                func_infos[actual_count - 1].name,
                func_infos[actual_count - 1].name);
    }

    fprintf(OpInstrSetFile, "};\n\n");
    
    fprintf(OpInstrSetFile, "#define LEN_INSTR_SET sizeof(op_instr_set) / sizeof(*op_instr_set)\n");

    free(func_infos);
    return GEN_SUCCESS;
}


int CmpOpInstrSetByHash(const void *a, const void *b)
{
    const op_instr_t *op_instr_a = (const op_instr_t*)a;
    const op_instr_t *op_instr_b = (const op_instr_t*)b;

    if (op_instr_a->hash > op_instr_b->hash)
        return 1;
    if (op_instr_a->hash == op_instr_b->hash)
        return 0;
    return -1;
}


int CmpByHash(const void *a, const void *b)
{
    const hash_t *hash_a = (const hash_t*)a;
    const hash_t *hash_b = (const hash_t*)b;

    if (*hash_a > *hash_b)
        return 1;
    if (*hash_a == *hash_b)
        return 0;
    return -1;
}


void RemoveComments(char** arr_ptr, size_t *count_line)
{
    for (size_t i = 0; i < *count_line; ++i)
    {
        char* colon = strchr(arr_ptr[i], '#');

        if (colon != NULL)
            *colon = '\0';
    }
}