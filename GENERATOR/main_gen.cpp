#include "WolfGen.h"

#define PATH_TO_SRC_FILE  "GENERATOR/src/func.txt"
#define PATH_TO_WOLF_OP_H "GENERATOR/ReportFiles/WolfOp.h"


int main()
{
    FILE *SourceFile     = fopen(PATH_TO_SRC_FILE, "r");
    if (IS_BAD_PTR(SourceFile)) { perror(ANSI_COLOR_RED "Bad pointer SourceFile:" ANSI_COLOR_RESET); return 1; }
    
    FILE *WolfOpFile     = fopen(PATH_TO_WOLF_OP_H, "w");
    if (IS_BAD_PTR(WolfOpFile)) { perror(ANSI_COLOR_RED "Bad pointer WolfOpFile:" ANSI_COLOR_RESET); return 1; }
    
    // FILE *OpInstrSetFile = fopen("./GENERATOR/ReportFiles/OpInstrSet.cpp", "w");
    // if (IS_BAD_PTR(OpInstrSetFile)) { perror(ANSI_COLOR_RED "Bad pointer OpInstrSetFile:" ANSI_COLOR_RESET); return 1; }


    char* buffer = NULL;
    size_t len_buffer = 0;
    size_t count_line = 0;
    char **arr_ptr = TXTreader(SourceFile, buffer, &len_buffer, &count_line, NULL);
    if (IS_BAD_PTR(arr_ptr))
        perror(ANSI_COLOR_RED "Error reading SourceFile!" ANSI_COLOR_RESET);


    RemoveComments(arr_ptr, &count_line);

    if (GenWolfOp(WolfOpFile, arr_ptr, count_line))
        perror(ANSI_COLOR_RED "Error creating WolfOpFile!" ANSI_COLOR_RESET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    // if (GenOpInstrSet(OpInstrSetFile, arr_ptr, count_line))
    //     perror(ANSI_COLOR_RED "Error creating OpInstrSetFile!" ANSI_COLOR_RESET);
    // else
    //     printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    free(arr_ptr);
    fclose(SourceFile);
    fclose(WolfOpFile);
    // fclose(OpInstrSetFile);
    
    return 0;
}


GenErr_t GenWolfOp(FILE *WolfOpFile, char **arr_ptr, size_t count_line)
{
    if (IS_BAD_PTR(WolfOpFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) return GEN_ERROR;
        
    fprintf(WolfOpFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");

    char** func_names = (char**)calloc(count_line, sizeof(char*));
    if (IS_BAD_PTR(func_names)) return GEN_ERROR;

    for (size_t i = 0; i < count_line; ++i)
    {
        func_names[i] = (char*)calloc(MAX_LEN_NAME_FUNC, sizeof(char));
        if (IS_BAD_PTR(func_names[i]))
        {
            for (size_t j = 0; j < i; ++j) free(func_names[j]);

            free(func_names);
            return GEN_ERROR;
        }
    }

    size_t count_names = 0;
    char op[8] = {0};

    int current_len = 0;
    int max_len     = 0;

    for (size_t line = 0; line < count_line; ++line)
    {
        if (*arr_ptr[line] == '\0') continue;
        
        char temp_name[32] = {0};
        if (sscanf(arr_ptr[line], "%[^:]%n: \"%[^\"]\";", temp_name, &current_len, op) == 2)
            max_len = (current_len > max_len) ? current_len : max_len;

        else
        {
            for (size_t i = 0; i < count_line; ++i) free(func_names[i]);
            free(func_names);

            return GEN_ERROR;
        }
    }

    fprintf(WolfOpFile, "#ifndef WOLF_OP_H\n"
                        "#define WOLF_OP_H\n\n\n");

    fprintf(WolfOpFile, "enum HashOp\n");
    fprintf(WolfOpFile, "{\n");

    for (size_t line = 0; line < count_line - 1; ++line)
    {
        if (*arr_ptr[line] == '\0') continue;

        if (sscanf(arr_ptr[line], "%[^:]: \"%[^\"]\";", func_names[count_names], op) == 2)
            fprintf(WolfOpFile, "\tHASH_%-*s = 0x%lX,\n", max_len, func_names[count_names++], HashStr(op));

        else
        {
            for (size_t i = 0; i < count_line; ++i) free(func_names[i]);
            free(func_names);

            return GEN_ERROR;
        }
    }

    if (sscanf(arr_ptr[count_line - 1], "%[^:]: \"%[^\"]\";", func_names[count_names], op) == 2)
        fprintf(WolfOpFile, "\tHASH_%-*s = 0x%lX\n", max_len, func_names[count_names++], HashStr(op));

    else
    {
        for (size_t i = 0; i < count_line; ++i) free(func_names[i]);
        free(func_names);

        return GEN_ERROR;
    }

    fprintf(WolfOpFile, "};\n\n");

    fprintf(WolfOpFile, "struct calc_context\n");
    fprintf(WolfOpFile, "{\n");
    fprintf(WolfOpFile, "    double left_val;\n");
    fprintf(WolfOpFile, "    double right_val;\n");
    fprintf(WolfOpFile, "};\n\n");
    
    fprintf(WolfOpFile, "struct diff_context\n");
    fprintf(WolfOpFile, "{\n");
    fprintf(WolfOpFile, "    node_t *node_left;\n");
    fprintf(WolfOpFile, "    node_t *node_right;\n");
    fprintf(WolfOpFile, "    hash_t hash_indep_var;\n");
    fprintf(WolfOpFile, "};\n\n\n");

    for (int i = 0; i < count_names; ++i) {
        fprintf(WolfOpFile, "double calc%s(calc_context *calc_params);\n", func_names[i]);
        fprintf(WolfOpFile, "node_t *diff%s(diff_context *diff_params);\n\n", func_names[i]);
    }

    fprintf(WolfOpFile, "typedef double (*calc_t)(calc_context *calc_params);\n");
    fprintf(WolfOpFile, "typedef node_t *(*diff_t)(diff_context *diff_params);\n\n\n");
    
    fprintf(WolfOpFile, "struct op_t\n");
    fprintf(WolfOpFile, "{\n");
    fprintf(WolfOpFile, "\tHashOp hash;\n");
    fprintf(WolfOpFile, "\tchar   name[8];\n");
    fprintf(WolfOpFile, "\tcalc_t calc;\n");
    fprintf(WolfOpFile, "\tdiff_t diff;\n");
    fprintf(WolfOpFile, "};\n\n\n");
    
    fprintf(WolfOpFile, "#endif\n");

    for (size_t i = 0; i < count_line; ++i) free(func_names[i]);
    free(func_names);
    return GEN_SUCCESS;
}


// int CmpByHash(const void *a, const void *b)
// {
//     const asm_instr_t *arr_instr_a = (const asm_instr_t*)a;
//     const asm_instr_t *arr_instr_b = (const asm_instr_t*)b;

//     if (arr_instr_a->hash > arr_instr_b->hash)
//         return 1;
//     if (arr_instr_a->hash == arr_instr_b->hash)
//         return 0;
//     return -1;
// }



void RemoveComments(char** arr_cmd, size_t *count_line)
{
    for (size_t i = 0; i < *count_line; ++i)
    {
        char* colon = strchr(arr_cmd[i], '#');

        if (colon != NULL)
            *colon = '\0';
    }
}